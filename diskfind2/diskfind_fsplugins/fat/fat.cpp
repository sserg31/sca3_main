#include <QStringList>
#include <QDebug>
#include <QDir>

#include <limits.h>

#include "fat.h"

#include "io.h"
#include "boot.h"
#include "fat1.h"
#include "check.h"
#include "file.h"

int write_immed = 0;
int verbose = 0;
int atari_format = 0;
int rw = 0, list = 0, test = 0;
int interactive = 0;
unsigned n_files = 0;
void *mem_queue = NULL;

unsigned char fat_esc2uni[256] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x3e, 0xff, 0x3f, 0xff, 0xff,
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
        0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32,
        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
        0x3b, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

FatPlugin::FatPlugin()
{

}

FatPlugin::~FatPlugin()
{

}

char *FatPlugin::path_name(DOS_FILE *file)
{
    static char path[PATH_MAX*2];

    if (!file) *path = 0;       /* Reached the root directory */
    else {
        if (strlen(path_name(file->parent)) > PATH_MAX)
            qWarning() << "Path name too long.";
        if (strcmp(path,"/") != 0) strcat(path,"/");

        /* Append the long name to the path,
         * or the short name if there isn't a long one
         */
        strcpy(strrchr(path,0),file->lfn?file->lfn:file_name(file->dir_ent.name));
    }
    return path;
}

QString FatPlugin::getFilename(quint64 offset)
{
    offset = offset - m_fs.data_start;

    // do not forget 2 additional clusters
    unsigned long cluster = offset / m_fs.cluster_size + 2;

    DOS_FILE *file = get_owner(&m_fs, cluster);

    QByteArray tmp = path_name(file);
    int pos = 0;

    while((pos = tmp.indexOf(':', pos)) != -1)
    {
        int code = fat_esc2uni[tmp[pos+1]];
        code <<= 6;
        code |= fat_esc2uni[tmp[pos+2]];
        code <<= 6;
        code |= fat_esc2uni[tmp[pos+3]];
#ifdef X64
        tmp.replace(pos, 4, QString::fromUtf16((const ushort *)&code, 1).toUtf8().mid(1));
#else
        tmp.replace(pos, 4, QString::fromUtf16((const ushort *)&code, 1).toUtf8());
#endif
    }

    return QString::fromUtf8(tmp);
}

int FatPlugin::prepare(const QString &tmpPath, const QString &device)
{
    fs_open(device.toAscii().data(), 0);
    read_boot(&m_fs);
    read_fat(&m_fs);

    unsigned long total_num_clusters = m_fs.clusters + 2UL;

    m_len = total_num_clusters * sizeof(DOS_FILE *);
    m_tmpFilename = QDir(tmpPath).absoluteFilePath(device.mid(device.lastIndexOf('/') + 1));

    if (!filePrepare(m_tmpFilename, m_len, &m_fd))
        return 0;

    if (!map((void**)&m_fs.cluster_owner, m_len, m_fd))
        return 0;

    memset(m_fs.cluster_owner, 0, m_len);

    post_read_fat(&m_fs);

    return scan_root(&m_fs) == 0;
}

int FatPlugin::finalize()
{
    fileFinalyze(m_fs.cluster_owner, m_len, m_fd);

    if (!QFile::remove(m_tmpFilename))
        perror("Error removing temporary file");

    return 0;
}

bool FatPlugin::fsmatch(const QString &type)
{
    QStringList list = QStringList() << "fat12" << "fat16" << "fat32";

    return list.contains(type, Qt::CaseInsensitive);
}

Q_EXPORT_PLUGIN2(fatplugin, FatPlugin);
